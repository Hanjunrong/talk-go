# 15 | 基础篇：Linux内存是怎么工作的？

Linux内核给每个进程都提供了一个独立的虚拟地址空间, 并且地址空间连续

虚拟地址空间内部被分为 内核空间 和 用户空间 两部分

只有实际使用的虚拟内存才会分配物理内存, 分配物理内存后, 通过内存映射来管理

内存映射就是将虚拟内存地址映射到物理内存地址

内核为每个进程维护一张页表, 记录映射关系

页表存储在CPU的内存管理单元MMU中, 处理器可以直接通过硬件, 找到要访问的内存

MMU规定一页为4K的最小单位

为解决页表大的问题, linux提供两种机制, 多级页表和大页

linux用四级页表来管理内存页

大页是比普通页更大的内存块, 常见2MB,1GB, 大页通常用子啊使用大量内存的进程上, 如oracle

## 虚拟内存空间分布

用户空间内存，从低到高分别是五种不同的内存段。

1. 只读段，包括代码和常量等。(const) 由于是只读的，不会再去分配新的内存，不会产生内存泄漏。

2. 数据段，包括全局变量和静态变量。(var) 这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏

3. 堆，包括动态分配的内存，从低地址开始向上增长。

4. 文件映射段(/内存映射段)，包括动态库、共享内存等，从高地址开始向下增长。其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。

5. 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB, 栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。

在这五个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。 Hack the Virtual Memory: malloc, the heap & the program break


# 16 | 基础篇：怎么理解内存中的Buffer和Cache？

# 17 | 案例篇：如何利用系统缓存优化程序的运行效率？

# 18 | 案例篇：内存泄漏了，我该如何定位和处理？

# 19 | 案例篇：为什么系统的Swap变高了（上）

# 20 | 案例篇：为什么系统的Swap变高了？（下）

# 21 | 套路篇：如何“快准狠”找到系统内存的问题？




