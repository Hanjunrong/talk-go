# 23 | 基础篇：Linux 文件系统是怎么工作的？

* 磁盘为系统提供了最基本的持久化存储。

* 文件系统则在磁盘的基础上，提供了一个用来管理文件的树状结构。

## 索引节点和目录项

Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。

Linux 文件系统为每个文件都分配两个数据结构:

* 索引节点 inode

索引节点是每个文件的唯一标志

* 目录项 dentry

目录项维护的正是文件系统的树状结构

目录项和索引节点的关系是多对一

![](https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png)

目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据

磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中，

* 超级块，存储整个文件系统的状态。

* 索引节点区，用来存储索引节点。

* 数据块区，则用来存储文件数据。

## 虚拟文件系统

目录项、索引节点、逻辑块以及超级块，构成了 Linux 文件系统的四大基本要素。

Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统 VFS（Virtual File System）。

![](https://static001.geekbang.org/resource/image/72/12/728b7b39252a1e23a7a223cdf4aa1612.png)

## 文件系统 I/O

文件读写方式的各种差异，导致 I/O 的分类多种多样。

最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等

第一种，根据是否利用标准库缓存，可以把文件 I/O 分为缓冲 I/O 与非缓冲 I/O。

* 缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。

* 非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存。

第二，根据是否利用操作系统的页缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O。

* 直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。

* 非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。

第三，根据应用程序是否阻塞自身运行，可以把文件 I/O 分为阻塞 I/O 和非阻塞 I/O：

* 所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。

* 所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。

第四，根据是否等待响应结果，可以把文件 I/O 分为同步和异步 I/O：

* 所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。

* 所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。

## 性能观测

### 容量


`$ df -h /dev/sda1 
Filesystem      Size  Used Avail Use% Mounted on 
/dev/sda1        29G  3.1G   26G  11% / `

 `$ df -i ` 查看索引节点的使用情况

### 缓存

free 或 vmstat，来观察页缓存的大小

实际性能分析中，使用 `slabtop`  ，来找到占用内存最多的缓存类型。

# 24,25 | 基础篇：Linux 磁盘I/O是怎么工作的

## 磁盘

* HDD

 随机I/O，它需要不停地移动磁头，来定位数据位置，所以读写速度就会比较慢。

* SSD

固态磁盘不需要磁道寻址

* 机械磁盘的最小读写单位是扇区，一般大小为 512 字节。

* 而固态磁盘的最小读写单位是页，通常大小是 4KB、8KB 等。

文件系统会把连续的扇区或页，组成逻辑块以提高效率(常见的逻辑块的大小是 4KB)

## 通用块层

## I/O 栈

Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。

* 文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。

* 通用块层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。

* 设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。

## 磁盘性能指标

* 使用率、饱和度、IOPS、吞吐量以及响应时间等。这五个指标，是衡量磁盘性能的基本指标。

* 使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。

* 饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。

* IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。

* 吞吐量，是指每秒的 I/O 请求大小。

* 响应时间，是指 I/O 请求从发出到收到响应的间隔时间。

## 磁盘 I/O 观测

`# -d -x表示显示所有磁盘I/O的指标
$ iostat -d -x 1 
Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util 
loop0            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 
loop1            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 
sda              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 
sdb              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 `


*%util  ，就是我们前面提到的磁盘 I/O 使用率；r/s+  w/s  ，就是 IOPS；rkB/s+wkB/s ，就是吞吐量；r_await+w_await ，就是响应时间。

## 进程 I/O 观测

`pidstat -d` 查看进程IO情况

`$ pidstat -d 1 
13:39:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command 
13:39:52      102       916      0.00      4.00      0.00       0  rsyslogd`

* 用户 ID（UID）和进程 ID（PID）  。

* 每秒读取的数据大小（kB_rd/s） ，单位是 KB。

* 每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。

* 每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。

* 块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。

`iotop` 可找到 I/O 较大的那些进程

`$ iotop
Total DISK READ :       0.00 B/s | Total DISK WRITE :       7.85 K/s 
Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s 
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND 
15055 be/3 root        0.00 B/s    7.85 K/s  0.00 %  0.00 % systemd-journald `

# 26 | 案例篇：如何找出狂打日志的“内鬼”？


# 27 | 案例篇：为什么我的磁盘I/O延迟很高？

先是top看%iowait到升高，再看pidstat是哪个进程在操作磁盘，再strace看进程的调用栈。
看/proc/meminfo就可以看到系统的buffer和cache各占了多少吧。前后一对比就知道是谁了。

# 28 | 案例篇：一个SQL查询要15秒，这是怎么回事？

mysql打开慢查询日志，排查SQL性能问题更方便

# 29 | 案例篇：Redis响应严重延迟，如何解决？


`$ docker exec -it redis redis-cli config get 'append*'
1) "appendfsync"
2) "always"
3) "appendonly"
4) "yes"`

Redis 提供了两种数据持久化的方式，分别是快照和追加文件。

快照方式，会按照指定的时间间隔，生成数据的快照，并且保存到磁盘文件中。为了避免阻塞主进程，Redis 还会 fork 出一个子进程，来负责快照的保存。这种方式的性能好，无论是备份还是恢复，都比追加文件好很多。不过，它的缺点也很明显。在数据量大时，fork 子进程需要用到比较大的内存，保存数据也很耗时。所以，你需要设置一个比较长的时间间隔来应对，比如至少 5 分钟。这样，如果发生故障，你丢失的就是几分钟的数据。

追加文件，则是用在文件末尾追加记录的方式，对 Redis 写入的数据，依次进行持久化，所以它的持久化也更安全。

此外，它还提供了一个用 appendfsync 选项设置 fsync 的策略，确保写入的数据都落到磁盘中，具体选项包括 always、everysec、no 等。

* always 表示，每个操作都会执行一次 fsync，是最为安全的方式；

* everysec 表示，每秒钟调用一次 fsync ，这样可以保证即使是最坏情况下，也只丢失 1 秒的数据；

* no 表示交给操作系统来处理。

问题小结:

第一个问题，Redis 配置的 appendfsync 是 always，这就导致 Redis 每次的写操作，都会触发 fdatasync 系统调用。今天的案例，没必要用这么高频的同步写，使用默认的 1s 时间间隔，就足够了。

第二个问题，Python 应用在查询接口中会调用 Redis 的 SADD 命令，这很可能是不合理使用缓存导致的。

# 第四阶段总结 (6.15 - 6.21):

本阶段主要讲解了IO方面的知识, 概念性的东西比较多, 不容易记住. 通过看完基本概念后, 大致理解了linux一切皆文件的设计理念

本章内容的案例篇很有实践意义, 需要今后重点回顾, 这些案例都是日常工作比较棘手问题的解决途径


