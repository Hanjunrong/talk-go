# talk-go
talk-go读书汇笔记汇总

## 运行环境 Ubuntu 20.04  4CPU 8G内存

### 平均负载案例分析
安装iostat mpstat pidstat 命令

`$ apt install sysstat`

`$ apt install stress`  stress  linux系统压力测试工具

`$ apt install stress-ng`  stress  linux系统压力测试工具升级版


### 平均负载

平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。

#### 可运行状态

所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

#### 不可中断状态

不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。不可中断状态实际上是系统对进程和硬件设备的一种保护机制

####  平均负载的合理值

当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。


当定位到某个程序负载过高时, 可以记住它的pid, 使用 `$ lsof -p pid` 来定位程序的路径

#### CPU上下文切换

多个进程在切换执行时会导致系统负载升高, CPU的上下文切换就是导致的原因之一

CPU上下文就是运行任务前, 必须依赖的环境,包含CPU寄存器和程序计数器

CPU上下文切换就是保存上个任务的上下文,加载下个任务的上下文,运行新任务

保存的上下文会存储在系统内核中

CPU上下文切换分为进程上下文切换, 线程上下文切换, 中断上下文切换

#### linux进程5种状态

linux上进程有5种状态: 
1. 运行(正在运行或在运行队列中等待) 
2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 
3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 
4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 
5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) 

ps工具标识进程的5种状态码: 

D 不可中断 uninterruptible sleep (usually IO) 

R 运行 runnable (on run queue) 

S 中断 sleeping 

T 停止 traced or stopped 

Z 僵死 a defunct (”zombie”) process 

#### 什么是linux软中断

软中断

为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：

上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。
下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。
也可以理解为：

上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；
而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。
网卡接收数据包的例子：

网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。你可以自己先想一下，这种情况下的上半部和下半部分别负责什么工作呢？

对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。

而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。


#### 进程的状态

进程状态

top 和 ps 是最常用的查看进程状态的工具，输出中 S 列（也就是 Status 列）表示进程的状态，经常可以看到 R、D、Z、S、I 等几个状态，它们分别是什么意思呢？

$ top

进程状态

top 和 ps 是最常用的查看进程状态的工具，输出中 S 列（也就是 Status 列）表示进程的状态，经常可以看到 R、D、Z、S、I 等几个状态，它们分别是什么意思呢？

$ top

PID   USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND

28961 root      20   0   43816   3148   4040 R   3.2  0.0   0:00.01 top

620   root      20   0   37280  33676    908 D   0.3  0.4   0:00.01 app

1     root      20   0  160072   9416   6752 S   0.0  0.1   0:37.64 systemd

1896  root      20   0       0      0      0 Z   0.0  0.0   0:00.00 devapp

2     root      20   0       0      0      0 S   0.0  0.0   0:00.10 kthreadd

4     root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:0H

6     root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu_wq

7     root      20   0       0      0      0 S   0.0  0.0   0:06.37 ksoftirqd/0

R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。

D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。

Z 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。

S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。

I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上
并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。

T 也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。

X 是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。

R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。

D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。

Z 是 Zombie 的缩写，它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。

S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。

I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。

T 也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。

X 是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。

#### CPU性能优化的几个思路

##### 应用程序的优化

写代码最重要的优化,减少循环层次, 减少递归, 减少动态内存分配
平时多学习大神们的代码, 逐渐地使用更优的编码思路

· 算法优化

· 异步处理

· 多线程代替多进程

· 善用缓存

##### 系统优化

CPU 绑定

CPU 独占

优先级调整

为进程设置资源限制

NUMA 优化: 让CPU尽可能地使用本地内存

中断负载均衡

##### 千万避免过早优化

代码都是由简到繁的, 先保证简单的没有问题

##### 性能评估”三步走“：

确定想的量化指标；

测试优化前的性能指标；

测试优化后的性能指标；


#### QPS 和 TPS 的区别

QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。

TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

Tps即每秒处理事务数，包括了
1）用户请求服务器
2）服务器自己的内部处理
3）服务器返回给用户

这三个过程，每秒能够完成N个这三个过程，Tps也就是3；

2、Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。 


# 第一阶段总结  第一周（5.25~5.31）
遇到的问题: 

环境准备的还是不够充分 家中电脑和公司电脑都要能够立即进入学习状态

收获: 

可以带着目标学习倪老师的教程, 看小伙伴们的石墨文档链接, 在群里看大家的讨论总结, 可以立马在机器上验证自己的想法

我为什么要学习这门课程:

不想自己遇到性能问题时一筹莫展, 不想出问题后没有排查思路, 不想与别人交流时听不懂一些名词指标

给自己设立一个学习目标,分阶段完成,试验自学效果,在业余时间也有学习的紧张感,压迫感, 否则会无休止的玩游戏,消耗完业余时间且没有收获

深入了解一点linux的知识, 充分了解自己写的代码的性能, 运行状态, 不能一抹黑, 对同事和公司造成隐患

说明:

第一阶段刚加入talk-go读书会, 还没有充分制定学习计划, 第二周第一天补上

对第一阶段笔记📒整理不够, 文档只看到了第三章, 第二周每晚补上

第一阶段总结暂不涉及知识点, 知识点的总结另开文档补充, 依据学有所获,学有所查,硬背是不可能的


# 第二阶段总结  第二周（6.1~6.7）

感觉本周的文章内容偏向于实践, 必须要在机器上实际地去做, 去实践才可以. 

自己折腾于docker, ubuntu, mac 中, 

可能在解决问题上不是很深入. 由于自己白天比较忙碌, 就空闲的时间不是很愿意折腾, 

会跳过没有解决的问题, 走马观花.希望下一阶段能够补一下没完成的实战

感觉看一遍不是很能熟练掌握, 而且工具小而多, 参数繁杂, 暂且有个印象, 可以有笔记可查

希望逐步地能形成自己linux排查问题的一套思路



